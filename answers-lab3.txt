1) What is the purpose of having an individual handler function for each exception/interrupt? 
(i.e., if all exceptions/interrupts were delivered to the same handler, what feature that 
exists in the current implementation could not be provided?)

Having an individual handler function for each exception/interrupt allows for specialized behavior
per each exception/interrupt. If all exceptions/interrupts lived in the same handler then it would 
be impossible for the CPU to provide a way to recover from a page fault as it wouldn’t know when to 
assign a new page and return. This type of implementation also allows for certain exceptions/interrupts 
to only be callable by the kernel.

2) Did you have to do anything to make the user/softint program behave correctly? 
The grade script expects it to produce a general protection fault (trap 13), but softint’s code says int $14.
 Why should this produce interrupt vector 13? What happens if the kernel actually allows softint’s int $14 
 instruction to invoke the kernel’s page fault handler (which is interrupt vector 14)?

Nothing extra needed to be done to make the user/softint program behave correctly. The softint program should 
produce an interrupt vector of 13 as $14 the page faulting interrupt is a kernel only interrupt. If the kernel 
allowed a page fault to occur then a user program could potentially use all the memory in the system by repeatedly 
calling page faults and having new pages assigned. 

3) The break point test case will either generate a breakpoint exception or a general protection fault depending 
on how you initialized the break point entry in the IDT (i.e., your call to SETGATE from trap_init). Why? How do 
you need to set it up in order to get the breakpoint exception to work as specified above and what incorrect setup 
would cause it to trigger a general protection fault?

The SETGATE needs to have ring permission 3 so that the user can trigger the breakpoint exception. 
If the SETGATE were to only have kernel level permissions a general protection fault would be generated as the 
program wouldn’t be able to set its breakpoints.

4) What do you think is the point of these mechanisms, particularly in light of what the user/softint test program does?

I think the point of these mechanisms is to provide security to the system so that user level programs 
can’t trigger kernel level exceptions and get more access to the system than they should.


